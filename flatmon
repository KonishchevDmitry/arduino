#!/usr/bin/env python3
#
# Indoor air quality monitoring daemon.
#
# requirements.txt: object_validator pcli pyserial pyyaml requests

import logging
import os.path
import sys
import time

import object_validator
import pcli.log
import requests
import serial
import yaml

from object_validator import Dict, DictScheme, Integer, String

log = logging.getLogger(__name__)


class Error(Exception):
    def __init__(self, *args):
        message, args = args[0], args[1:]
        super(Error, self).__init__(message.format(*args) if args else message)


class Thingspeak:
    RATE_LIMIT_SECONDS = 15

    def __init__(self, config):
        self.__write_api_key = config["write_api_key"]
        self.__sensors = config["sensors"]

        # FIXME: support few sensors
        self.__last_update_time = 0

    def on_sensor_metrics(self, sensor_id, humidity, temperature):
        try:
            sensor_info = self.__sensors[sensor_id]
        except KeyError:
            log.error("Got metrics from an unknown sensor #%s.", sensor_id)
            return

        sensor_name = sensor_info["name"]
        log.info("Got metrics from %s sensor.", sensor_name)

        if time.time() - self.__last_update_time < self.RATE_LIMIT_SECONDS:
            return

        log.info("Sending metrics to %s channel...", sensor_name)

        # FIXME: Send metrics asynchronously
        try:
            self.__send_metrics(sensor_info["channel_id"], humidity, temperature)
        except Exception as e:
            log.error("Unable to send metrics to %s channel: %s", sensor_name, e)
        finally:
            self.__last_update_time = time.time()

    def __send_metrics(self, channel_id, humidity, temperature):
        response = requests.post("https://api.thingspeak.com/update.json", headers={
            "THINGSPEAKAPIKEY": self.__write_api_key,
        }, json={
            "channel_id": channel_id,
            "field1": humidity,
            "field2": temperature,
        }, timeout=5)

        if response.status_code != requests.codes.ok:
            raise Error("The server returned an error: {} {}", response.status_code, response.reason)

        try:
            result = response.json()
        except ValueError as e:
            raise Error("Got an invalid response from server: {}.", e)

        if result == 0:
            log.error("API rate limit has been reached for %s channel.", channel_id)
            return False

        try:
            object_validator.validate("result", result, DictScheme({
                "channel_id": Integer(choices=(channel_id,)),
            }, ignore_unknown=True))
        except object_validator.ValidationError:
            raise Error("Got an unexpected response from the server.")

        return True


def load_config(path):
    try:
        with open(path) as config_file:
            config = yaml.load(config_file)
    except EnvironmentError as e:
        raise Error("Unable to load '{}' config file: {}.", path, os.strerror(e.errno))
    except ValueError as e:
        raise Error("Error while reading '{}' config file: {}.", path, e)

    try:
        config = object_validator.validate("config", config, DictScheme({
            "receiver": DictScheme({
                "device": String(min_length=1),
            }),
            "thingspeak": DictScheme({
                "write_api_key": String(min_length=1),
                "sensors": Dict(Integer(min=0), DictScheme({
                    "name": String(min_length=1),
                    "channel_id": Integer(min=0),
                })),
            })
        }))
    except object_validator.ValidationError as e:
        raise Error("Error while reading '{}' config file: {}", path, e)

    return config


# FIXME: to class
def monitor(device_path, thingspeak):
    # FIXME: Handle device unavailability and temporary disconnection

    log.info("Connecting to %s...", device_path)
    receiver = serial.Serial(device_path, 9600)
    log.info("Connected to %s.", device_path)

    while True:
        line = receiver.readline(1024).rstrip(b"\r\n")

        if line.startswith(b"> "):
            on_sensor_message(thingspeak, line[2:])
        else:
            try:
                line = line.decode("utf-8")
            except ValueError:
                log.error("Got an invalid UTF-8 string from port.")
            else:
                log.info("> %s", line)


def on_sensor_message(thingspeak, message):
    try:
        if len(message) != 6:
            raise ValueError

        sensor_id, humidity, temperature = (int(message[char:char+2], 16) for char in range(0, len(message), 2))
    except ValueError:
        log.error("Got an invalid sensor message from receiver: %r.", message)
        return

    # FIXME: support unknown values
    thingspeak.on_sensor_metrics(sensor_id, humidity, temperature)


# FIXME: Termination signal handling
def main():
    binary_path = os.path.abspath(__file__)
    config_path = os.path.join(os.path.dirname(binary_path), "flatmon.conf.yaml")

    try:
        config = load_config(config_path)
        pcli.log.setup(__name__)

        thingspeak = Thingspeak(config["thingspeak"])
        monitor(config["receiver"]["device"], thingspeak)
    except Error as e:
        sys.exit("Error: {}".format(e))
    except SystemExit:
        sys.exit("Exiting...")


if __name__ == "__main__":
    main()